// Copyright 2015 Canonical Ltd.

package jem

import (
	"context"
	"fmt"
	"math/rand"
	"strings"
	"sync"
	"time"

	"github.com/juju/clock"
	"github.com/juju/juju/api"
	"github.com/juju/juju/api/base"
	jujuapibase "github.com/juju/juju/api/base"
	cloudapi "github.com/juju/juju/api/cloud"
	"github.com/juju/juju/api/modelmanager"
	jujuparams "github.com/juju/juju/apiserver/params"
	jujucloud "github.com/juju/juju/cloud"
	"github.com/juju/juju/environs/config"
	"github.com/juju/juju/state/multiwatcher"
	"github.com/juju/utils/cache"
	"github.com/juju/version"
	"github.com/rogpeppe/fastuuid"
	"go.uber.org/zap"
	"gopkg.in/errgo.v1"
	"gopkg.in/juju/names.v2"
	"gopkg.in/macaroon-bakery.v2-unstable/httpbakery"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"

	"github.com/CanonicalLtd/jimm/internal/apiconn"
	"github.com/CanonicalLtd/jimm/internal/auth"
	"github.com/CanonicalLtd/jimm/internal/mgosession"
	"github.com/CanonicalLtd/jimm/internal/mongodoc"
	usageauth "github.com/CanonicalLtd/jimm/internal/usagesender/auth"
	"github.com/CanonicalLtd/jimm/internal/zapctx"
	"github.com/CanonicalLtd/jimm/internal/zaputil"
	"github.com/CanonicalLtd/jimm/params"
)

// wallClock provides access to the current time. It is a variable so
// that it can be overridden in tests.
var wallClock clock.Clock = clock.WallClock

// Functions defined as variables so they can be overridden in tests.
var (
	randIntn = rand.Intn

	NewUsageSenderAuthorizationClient = func(url string, client *httpbakery.Client) (UsageSenderAuthorizationClient, error) {
		return usageauth.NewAuthorizationClient(url, client), nil
	}
)

// UsageSenderAuthorizationClient is used to obtain authorization to
// collect and report usage metrics.
type UsageSenderAuthorizationClient interface {
	GetCredentials(ctx context.Context, applicationUser string) ([]byte, error)
}

// Params holds parameters for the NewPool function.
type Params struct {
	// DB holds the mongo database that will be used to
	// store the JEM information.
	DB *mgo.Database

	// SessionPool holds a pool from which session objects are
	// taken to be used in database operations.
	SessionPool *mgosession.Pool

	// ControllerAdmin holds the identity of the user
	// or group that is allowed to create controllers.
	ControllerAdmin params.User

	// UsageSenderURL holds the URL where we obtain authorization
	// to collect and report usage metrics.
	UsageSenderURL string

	// Client is used to make the request for usage metrics authorization
	Client *httpbakery.Client

	// PublicCloudMetadata contains the metadata details of all known
	// public clouds.
	PublicCloudMetadata map[string]jujucloud.Cloud
}

type Pool struct {
	config    Params
	connCache *apiconn.Cache

	// dbName holds the name of the database to use.
	dbName string

	// regionCache caches region information about models
	regionCache *cache.Cache

	// mu guards the fields below it.
	mu sync.Mutex

	// closed holds whether the Pool has been closed.
	closed bool

	// refCount holds the number of JEM instances that
	// currently refer to the pool. The pool is finally
	// closed when all JEM instances are closed and the
	// pool itself has been closed.
	refCount int

	usageSenderAuthorizationClient UsageSenderAuthorizationClient

	// uuidGenerator is used to generate temporary UUIDs during the
	// creation of models, these UUIDs will be replaced with the ones
	// generated by the controllers themselves.
	uuidGenerator *fastuuid.Generator
}

var APIOpenTimeout = 15 * time.Second

var notExistsQuery = bson.D{{"$exists", false}}

// NewPool represents a pool of possible JEM instances that use the given
// database as a store, and use the given bakery parameters to create the
// bakery.Service.
func NewPool(ctx context.Context, p Params) (*Pool, error) {
	// TODO migrate database
	if p.ControllerAdmin == "" {
		return nil, errgo.Newf("no controller admin group specified")
	}
	if p.SessionPool == nil {
		return nil, errgo.Newf("no session pool provided")
	}
	uuidGen, err := fastuuid.NewGenerator()
	if err != nil {
		return nil, errgo.Mask(err)
	}
	pool := &Pool{
		config:        p,
		dbName:        p.DB.Name,
		connCache:     apiconn.NewCache(apiconn.CacheParams{}),
		regionCache:   cache.New(24 * time.Hour),
		refCount:      1,
		uuidGenerator: uuidGen,
	}
	if pool.config.UsageSenderURL != "" {
		client, err := NewUsageSenderAuthorizationClient(p.UsageSenderURL, p.Client)
		if err != nil {
			return nil, errgo.Notef(err, "cannot make omnibus authorization client")
		}
		pool.usageSenderAuthorizationClient = client
	}
	jem := pool.JEM(ctx)
	defer jem.Close()
	if err := jem.DB.ensureIndexes(); err != nil {
		return nil, errgo.Notef(err, "cannot ensure indexes")
	}
	return pool, nil
}

// Close closes the pool. Its resources will be freed
// when the last JEM instance created from the pool has
// been closed.
func (p *Pool) Close() {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.closed {
		return
	}
	p.decRef()
	p.closed = true
}

func (p *Pool) decRef() {
	// called with p.mu held.
	if p.refCount--; p.refCount == 0 {
		p.connCache.Close()
	}
	if p.refCount < 0 {
		panic("negative reference count")
	}
}

// ClearAPIConnCache clears out the API connection cache.
// This is useful for testing purposes.
func (p *Pool) ClearAPIConnCache() {
	p.connCache.EvictAll()
}

// JEM returns a new JEM instance from the pool, suitable
// for using in short-lived requests. The JEM must be
// closed with the Close method after use.
//
// This method will panic if called after the pool has been
// closed.
func (p *Pool) JEM(ctx context.Context) *JEM {
	p.mu.Lock()
	defer p.mu.Unlock()
	if p.closed {
		panic("JEM call on closed pool")
	}
	p.refCount++
	return &JEM{
		DB:                             newDatabase(ctx, p.config.SessionPool, p.dbName),
		pool:                           p,
		usageSenderAuthorizationClient: p.usageSenderAuthorizationClient,
	}
}

// UsageAuthorizationClient returns the UsageSenderAuthorizationClient.
func (p *Pool) UsageAuthorizationClient() UsageSenderAuthorizationClient {
	return p.usageSenderAuthorizationClient
}

type JEM struct {
	// DB holds the mongodb-backed identity store.
	DB *Database

	// pool holds the Pool from which the JEM instance
	// was created.
	pool *Pool

	// closed records whether the JEM instance has
	// been closed.
	closed bool

	usageSenderAuthorizationClient UsageSenderAuthorizationClient
}

// Clone returns an independent copy of the receiver
// that uses a cloned database connection. The
// returned value must be closed after use.
func (j *JEM) Clone() *JEM {
	j.pool.mu.Lock()
	defer j.pool.mu.Unlock()

	j.pool.refCount++
	return &JEM{
		DB:   j.DB.clone(),
		pool: j.pool,
	}
}

func (j *JEM) ControllerAdmin() params.User {
	return j.pool.config.ControllerAdmin
}

// Close closes the JEM instance. This should be called when
// the JEM instance is finished with.
func (j *JEM) Close() {
	j.pool.mu.Lock()
	defer j.pool.mu.Unlock()
	if j.closed {
		return
	}
	j.closed = true
	j.DB.Session.Close()
	j.DB = nil
	j.pool.decRef()
}

// ErrAPIConnection is returned by OpenAPI, OpenAPIFromDoc and
// OpenModelAPI when the API connection cannot be made.
//
// Note that it is defined as an ErrorCode so that Database.checkError
// does not treat it as a mongo-connection-broken error.
var ErrAPIConnection params.ErrorCode = "cannot connect to API"

// OpenAPI opens an API connection to the controller with the given path
// and returns it along with the information used to connect. If the
// controller does not exist, the error will have a cause of
// params.ErrNotFound.
//
// If the controller API connection could not be made, the error will
// have a cause of ErrAPIConnection.
//
// The returned connection must be closed when finished with.
func (j *JEM) OpenAPI(ctx context.Context, path params.EntityPath) (_ *apiconn.Conn, err error) {
	defer j.DB.checkError(ctx, &err)
	ctl, err := j.DB.Controller(ctx, path)
	if err != nil {
		return nil, errgo.NoteMask(err, "cannot get controller", errgo.Is(params.ErrNotFound))
	}
	return j.OpenAPIFromDoc(ctx, ctl)
}

// OpenAPIFromDoc returns an API connection to the controller held in the
// given document. This can be useful when we want to connect to a
// controller before it's added to the database. Note that a successful
// return from this function does not necessarily mean that the
// credentials or API addresses in the docs actually work, as it's
// possible that there's already a cached connection for the given
// controller.
//
// The returned connection must be closed when finished with.
func (j *JEM) OpenAPIFromDoc(ctx context.Context, ctl *mongodoc.Controller) (*apiconn.Conn, error) {
	return j.pool.connCache.OpenAPI(ctx, ctl.UUID, func() (api.Connection, *api.Info, error) {
		info := apiInfoFromDoc(ctl)
		zapctx.Debug(ctx, "open API", zap.Any("api-info", info))
		conn, err := api.Open(info, apiDialOpts())
		if err != nil {
			return nil, nil, errgo.WithCausef(err, ErrAPIConnection, "")
		}
		return conn, info, nil
	})
}

func apiDialOpts() api.DialOpts {
	return api.DialOpts{
		Timeout:    APIOpenTimeout,
		RetryDelay: 500 * time.Millisecond,
	}
}

func apiInfoFromDoc(ctl *mongodoc.Controller) *api.Info {
	return &api.Info{
		Addrs:    mongodoc.Addresses(ctl.HostPorts),
		CACert:   ctl.CACert,
		Tag:      names.NewUserTag(ctl.AdminUser),
		Password: ctl.AdminPassword,
	}
}

// OpenModelAPI opens an API connection to the model with the given path
// and returns it along with the information used to connect. If the
// model does not exist, the error will have a cause of
// params.ErrNotFound.
//
// If the model API connection could not be made, the error will have a
// cause of ErrAPIConnection.
//
// The returned connection must be closed when finished with.
func (j *JEM) OpenModelAPI(ctx context.Context, path params.EntityPath) (_ *apiconn.Conn, err error) {
	defer j.DB.checkError(ctx, &err)
	m, err := j.DB.Model(ctx, path)
	if err != nil {
		return nil, errgo.NoteMask(err, "cannot get model", errgo.Is(params.ErrNotFound))
	}
	ctl, err := j.DB.Controller(ctx, m.Controller)
	if err != nil {
		return nil, errgo.Notef(err, "cannot get controller")
	}
	return j.openModelAPIFromDocs(ctx, ctl, m)
}

// openModelAPIFromDocs returns an API connection to the model held in the
// given documents.
//
// The returned connection must be closed when finished with.
func (j *JEM) openModelAPIFromDocs(ctx context.Context, ctl *mongodoc.Controller, m *mongodoc.Model) (*apiconn.Conn, error) {
	return j.pool.connCache.OpenAPI(ctx, m.UUID, func() (api.Connection, *api.Info, error) {
		info := apiInfoFromDocs(ctl, m)
		zapctx.Debug(ctx, "open API", zap.Any("api-info", info))
		conn, err := api.Open(info, apiDialOpts())
		if err != nil {
			zapctx.Info(ctx, "failed to open connection", zaputil.Error(err), zap.Any("api-info", info))
			return nil, nil, errgo.WithCausef(err, ErrAPIConnection, "")
		}
		return conn, info, nil
	})
}

func apiInfoFromDocs(ctl *mongodoc.Controller, m *mongodoc.Model) *api.Info {
	return &api.Info{
		Addrs:    mongodoc.Addresses(ctl.HostPorts),
		CACert:   ctl.CACert,
		ModelTag: names.NewModelTag(m.UUID),
		Tag:      names.NewUserTag(ctl.AdminUser),
		Password: ctl.AdminPassword,
	}
}

// Controller retrieves the given controller from the database,
// validating that the current user is allowed to read the controller.
func (j *JEM) Controller(ctx context.Context, path params.EntityPath) (*mongodoc.Controller, error) {
	if err := j.DB.CheckReadACL(ctx, j.DB.Controllers(), path); err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}
	ctl, err := j.DB.Controller(ctx, path)
	return ctl, errgo.Mask(err, errgo.Is(params.ErrNotFound))
}

// Credential retrieves the given credential from the database,
// validating that the current user is allowed to read the credential.
func (j *JEM) Credential(ctx context.Context, path params.CredentialPath) (*mongodoc.Credential, error) {
	cred, err := j.DB.Credential(ctx, path)
	if err != nil {
		if errgo.Cause(err) == params.ErrNotFound {
			// We return an authorization error for all attempts to retrieve credentials
			// from any other user's space.
			if aerr := auth.CheckIsUser(ctx, path.User); aerr != nil {
				err = aerr
			}
		}
		return nil, errgo.Mask(err, errgo.Is(params.ErrNotFound), errgo.Is(params.ErrUnauthorized))
	}
	if err := auth.CheckCanRead(ctx, cred); err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}
	return cred, nil
}

// CreateModelParams specifies the parameters needed to create a new
// model using CreateModel.
type CreateModelParams struct {
	// Path contains the path of the new model.
	Path params.EntityPath

	// ControllerPath contains the path of the owning
	// controller.
	ControllerPath params.EntityPath

	// Credential contains the name of the credential to use to
	// create the model.
	Credential params.CredentialPath

	// Cloud contains the name of the cloud in which the
	// model will be created.
	Cloud params.Cloud

	// Region contains the name of the region in which the model will
	// be created. This may be empty if the cloud does not support
	// regions.
	Region string

	// Attributes contains the attributes to assign to the new model.
	Attributes map[string]interface{}
}

// CreateModel creates a new model as specified by p.
func (j *JEM) CreateModel(ctx context.Context, p CreateModelParams) (_ *mongodoc.Model, err error) {
	// Only the owner can create a new model in their namespace.
	if err := auth.CheckIsUser(ctx, p.Path.User); err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}

	var usageSenderCredentials []byte
	if j.usageSenderAuthorizationClient != nil {
		usageSenderCredentials, err = j.usageSenderAuthorizationClient.GetCredentials(
			ctx,
			string(p.Path.User))
		if err != nil {
			return nil, errgo.Mask(err)
		}
	}

	cred, err := j.selectCredential(ctx, p.Credential, p.Path.User, p.Cloud)
	if err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrNotFound), errgo.Is(params.ErrAmbiguousChoice))
	}

	controllers, err := j.possibleControllers(ctx, p.ControllerPath, p.Cloud, p.Region)
	if err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrNotFound), errgo.Is(params.ErrUnauthorized))
	}

	// Create the model record in the database before actually
	// creating the model on the controller. It will have an invalid
	// UUID because it doesn't exist but that's better than creating
	// a model that we can't add locally because the name
	// already exists.
	modelDoc := &mongodoc.Model{
		Path:                   p.Path,
		CreationTime:           wallClock.Now(),
		Creator:                auth.Username(ctx),
		UsageSenderCredentials: usageSenderCredentials,
		// Use a temporary UUID so that we can create two at the
		// same time, because the uuid field must always be
		// unique.
		UUID: fmt.Sprintf("creating-%x", j.pool.uuidGenerator.Next()),
	}
	if cred != nil {
		modelDoc.Credential = cred.Path
	}
	if err := j.DB.AddModel(ctx, modelDoc); err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrAlreadyExists))
	}

	defer func() {
		if err == nil {
			return
		}

		// We're returning an error, so remove the model from the
		// database. Note that this might leave the model around
		// in the controller, but this should be rare and we can
		// deal with it at model creation time later (see TODO below).
		if err := j.DB.DeleteModel(ctx, modelDoc.Path); err != nil {
			zapctx.Error(ctx, "cannot remove model from database after error; leaked model", zaputil.Error(err))
		}
	}()

	var ctlPath params.EntityPath
	var modelInfo base.ModelInfo
	for _, controller := range controllers {
		var err error
		modelInfo, err = j.createModelOnController(ctx, controller, p, cred)
		if err == nil {
			ctlPath = controller
			break
		}
		if errgo.Cause(err) == errInvalidModelParams {
			return nil, errgo.Notef(err, "cannot create model")
		}
		zapctx.Error(ctx, "cannot create model on controller", zaputil.Error(err), zap.String("controller", controller.String()))
	}

	if ctlPath.Name == "" {
		return nil, errgo.New("cannot find suitable controller")
	}

	// Now set the UUID to that of the actually created model,
	// and update other attributes from the response too.
	// Use Apply so that we can return a result that's consistent
	// with Database.Model.
	info := mongodoc.ModelInfo{
		Life: string(modelInfo.Life),
		Status: mongodoc.ModelStatus{
			Status:  string(modelInfo.Status.Status),
			Message: modelInfo.Status.Info,
			Data:    modelInfo.Status.Data,
		},
	}
	if modelInfo.Status.Since != nil {
		info.Status.Since = *modelInfo.Status.Since
	}
	if modelInfo.AgentVersion != nil {
		info.Config = map[string]interface{}{
			config.AgentVersionKey: modelInfo.AgentVersion.String(),
		}
	}
	if _, err := j.DB.Models().FindId(modelDoc.Id).Apply(mgo.Change{
		Update: bson.D{{"$set", bson.D{
			{"uuid", modelInfo.UUID},
			{"controller", ctlPath},
			{"cloud", modelInfo.Cloud},
			{"cloudregion", modelInfo.CloudRegion},
			{"defaultseries", modelInfo.DefaultSeries},
			{"info", info},
			{"type", modelInfo.Type},
			{"providertype", modelInfo.ProviderType},
		}}},
		ReturnNew: true,
	}, &modelDoc); err != nil {
		j.DB.checkError(ctx, &err)
		return nil, errgo.Notef(err, "cannot update model %s in database", modelInfo.UUID)
	}
	j.DB.AppendAudit(ctx, &params.AuditModelCreated{
		ID:             modelDoc.Id,
		UUID:           modelInfo.UUID,
		Owner:          string(modelDoc.Owner()),
		Creator:        modelDoc.Creator,
		ControllerPath: ctlPath.String(),
		Cloud:          string(modelDoc.Cloud),
		Region:         modelDoc.CloudRegion,
	})
	return modelDoc, nil
}

func (j *JEM) possibleControllers(ctx context.Context, ctlPath params.EntityPath, cloud params.Cloud, region string) ([]params.EntityPath, error) {
	if ctlPath.Name != "" {
		return []params.EntityPath{ctlPath}, nil
	}
	cloudRegion, err := j.DB.CloudRegion(ctx, cloud, region)
	if err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrNotFound))
	}
	if err := auth.CheckCanRead(ctx, cloudRegion); err != nil {
		return nil, errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}
	controllers := cloudRegion.PrimaryControllers
	if len(controllers) == 0 {
		controllers = cloudRegion.SecondaryControllers
	}
	shuffle(len(controllers), func(i, j int) { controllers[i], controllers[j] = controllers[j], controllers[i] })
	return controllers, nil
}

// shuffle is used to randomize the order in which possible controllers
// are tried. It is a variable so it can be replaced in tests.
var shuffle func(int, func(int, int)) = rand.Shuffle

const errInvalidModelParams params.ErrorCode = "invalid CreateModel request"

func (j *JEM) createModelOnController(ctx context.Context, ctlPath params.EntityPath, p CreateModelParams, cred *mongodoc.Credential) (base.ModelInfo, error) {
	ctl, err := j.Controller(ctx, ctlPath)
	if err != nil {
		return base.ModelInfo{}, errgo.Notef(err, "cannot get controller document")
	}
	if ctl.Deprecated {
		return base.ModelInfo{}, errgo.Notef(err, "controller deprecated")
	}
	conn, err := j.OpenAPIFromDoc(ctx, ctl)
	if err != nil {
		return base.ModelInfo{}, errgo.Notef(err, "cannot connect to controller")
	}
	defer conn.Close()

	var credTag names.CloudCredentialTag
	if cred != nil {
		if err := j.updateControllerCredential(ctx, conn, ctlPath, cred, nil); err != nil {
			return base.ModelInfo{}, errgo.Notef(err, "cannot add credential")
		}
		if err := j.DB.credentialAddController(ctx, cred.Path, ctlPath); err != nil {
			return base.ModelInfo{}, errgo.Notef(err, "cannot add credential")
		}
		credTag = CloudCredentialTag(cred.Path)
	}

	mmClient := modelmanager.NewClient(conn.Connection)
	m, err := mmClient.CreateModel(
		string(p.Path.Name),
		UserTag(p.Path.User).Id(),
		string(p.Cloud),
		p.Region,
		credTag,
		p.Attributes,
	)
	if err != nil {
		switch jujuparams.ErrCode(err) {
		case jujuparams.CodeAlreadyExists:
			// The model already exists in the controller but it didn't
			// exist in the database. This probably means that it's
			// been abortively created previously, but left around because
			// of connection failure.
			// TODO initiate cleanup of the model, first checking that
			// it's empty, but return an error to the user because
			// the operation to delete a model isn't synchronous even
			// for empty models. We could also have a worker that deletes
			// empty models that don't appear in the database.
			return base.ModelInfo{}, errgo.Notef(err, "model name in use")
		case jujuparams.CodeUpgradeInProgress:
			return base.ModelInfo{}, errgo.Notef(err, "upgrade in progress")
		default:
			// The model couldn't be created because of an
			// error in the request, don't try another
			// controller.
			return base.ModelInfo{}, errgo.WithCausef(err, errInvalidModelParams, "")
		}
	}
	// TODO should we try to delete the model from the controller
	// on error here?

	// Grant JIMM admin access to the model. Note that if this fails,
	// the local database entry will be deleted but the model
	// will remain on the controller and will trigger the "already exists
	// in the backend controller" message above when the user
	// attempts to create a model with the same name again.
	if err := mmClient.GrantModel(conn.Info.Tag.(names.UserTag).Id(), "admin", m.UUID); err != nil {
		// TODO (mhilton) ensure that this is flagged in some admin interface somewhere.
		zapctx.Error(ctx, "leaked model", zap.String("controller", ctlPath.String()), zap.String("model", p.Path.String()), zaputil.Error(err), zap.String("model-uuid", m.UUID))
		return base.ModelInfo{}, errgo.Notef(err, "cannot grant model access")
	}
	return m, nil
}

// RevokeCredential checks that the credential with the given path
// can be revoked (if flags&CredentialCheck!=0) and revokes
// the credential (if flags&CredentialUpdate!=0).
// If flags==0, it acts as if both CredentialCheck and CredentialUpdate
// were set.
func (j *JEM) RevokeCredential(ctx context.Context, credPath params.CredentialPath, flags CredentialUpdateFlags) error {
	if flags == 0 {
		flags = ^0
	}
	cred, err := j.DB.Credential(ctx, credPath)
	if err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrNotFound))
	}
	controllers := cred.Controllers
	if flags&CredentialCheck != 0 {
		models, err := j.DB.ModelsWithCredential(ctx, credPath)
		if err != nil {
			return errgo.Mask(err)
		}
		if len(models) > 0 {
			// TODO more informative error message.
			return errgo.Newf("cannot revoke because credential is in use on at least one model")
		}
	}
	if flags&CredentialUpdate == 0 {
		return nil
	}
	if err := j.DB.updateCredential(ctx, &mongodoc.Credential{
		Path:    credPath,
		Revoked: true,
	}); err != nil {
		return errgo.Notef(err, "cannot update local database")
	}
	ch := make(chan struct{}, len(controllers))
	n := len(controllers)
	for _, ctlPath := range controllers {
		ctlPath, j := ctlPath, j.Clone()
		go func() {
			defer func() {
				ch <- struct{}{}
			}()
			defer j.Close()
			conn, err := j.OpenAPI(ctx, ctlPath)
			if err != nil {
				zapctx.Warn(ctx,
					"cannot connect to controller to revoke credential",
					zap.String("controller", ctlPath.String()),
					zaputil.Error(err),
				)
				return
			}
			defer conn.Close()

			err = j.revokeControllerCredential(ctx, conn, ctlPath, cred.Path)
			if err != nil {
				zapctx.Warn(ctx,
					"cannot revoke credential",
					zap.String("controller", ctlPath.String()),
					zaputil.Error(err),
				)
			}
		}()
	}
	for n > 0 {
		select {
		case <-ch:
			n--
		case <-ctx.Done():
			return errgo.Notef(ctx.Err(), "timed out revoking credentials")
		}
	}
	return nil
}

type CredentialUpdateFlags int

const (
	CredentialUpdate CredentialUpdateFlags = 1 << iota
	CredentialCheck
)

// UpdateCredential checks that the credential can be updated (if the
// CredentialUpdate flag is set) and updates its in the local database
// and all controllers to which it is deployed (if the CredentialCheck
// flag is specified).
//
// If flags is zero, it will both check and update.
func (j *JEM) UpdateCredential(ctx context.Context, cred *mongodoc.Credential, flags CredentialUpdateFlags) (*jujuparams.UpdateCredentialResult, error) {
	if cred.Revoked {
		return nil, errgo.Newf("cannot use UpdateCredential to revoke a credential")
	}
	if flags == 0 {
		flags = ^0
	}
	var controllers []params.EntityPath
	c, err := j.DB.Credential(ctx, cred.Path)
	if err == nil {
		controllers = c.Controllers
	} else if errgo.Cause(err) != params.ErrNotFound {
		return nil, errgo.Mask(err)
	}
	if flags&CredentialCheck != 0 {
		// There is a credential already recorded, so check with all its controllers
		// that it's valid before we update it locally and update it on the controllers.
		r, err := j.checkCredential(ctx, cred, controllers)
		if err != nil {
			return nil, errgo.Mask(err)
		}
		// Note: r.Error is non-nil if there are any models that contain an error.
		if r.Error != nil || flags&CredentialUpdate == 0 {
			return r, nil
		}
	}
	// Note that because CredentialUpdate is checked for inside the
	// CredentialCheck case above, we know that we need to
	// update the credential in this case.
	r, err := j.updateCredential(ctx, cred, controllers)
	if err != nil {
		return nil, errgo.Mask(err)
	}
	return r, nil
}

func (j *JEM) updateCredential(ctx context.Context, cred *mongodoc.Credential, controllers []params.EntityPath) (*jujuparams.UpdateCredentialResult, error) {
	// The credential has now been checked (or we're going
	// to force the update), so update it in the local database.
	// and mark in the local database that an update is required for
	// all controllers
	if err := j.DB.updateCredential(ctx, cred); err != nil {
		return nil, errgo.Notef(err, "cannot update local database")
	}
	if err := j.DB.setCredentialUpdates(ctx, cred.Controllers, cred.Path); err != nil {
		return nil, errgo.Notef(err, "cannot mark controllers to be updated")
	}

	// Attempt to update all controllers to which the credential is
	// deployed. If these fail they will be updated by the monitor.
	// Make the channel buffered so we don't leak go-routines
	ch := make(chan updateCredentialResult, len(controllers))
	for _, ctlPath := range controllers {
		ctlPath, j := ctlPath, j.Clone()
		go func() {
			defer j.Close()
			conn, err := j.OpenAPI(ctx, ctlPath)
			if err != nil {
				ch <- updateCredentialResult{
					ctlPath: ctlPath,
					err:     errgo.Mask(err),
				}
				return
			}
			defer conn.Close()

			var r *jujuparams.UpdateCredentialResult
			err = j.updateControllerCredential(ctx, conn, ctlPath, cred, &r)
			ch <- updateCredentialResult{
				ctlPath: ctlPath,
				err:     err,
				r:       r,
			}
		}()
	}
	r, err := mergeUpdateCredentialResults(ctx, ch, len(controllers), false)
	if err != nil {
		return nil, errgo.Mask(err)
	}
	return r, nil
}

func (j *JEM) checkCredential(ctx context.Context, newCred *mongodoc.Credential, controllers []params.EntityPath) (*jujuparams.UpdateCredentialResult, error) {
	if len(controllers) == 0 {
		// No controllers, so there's nowhere to check that the credential
		// is valid.
		return &jujuparams.UpdateCredentialResult{
			CredentialTag: CloudCredentialTag(newCred.Path).String(),
		}, nil
	}
	ch := make(chan updateCredentialResult, len(controllers))
	for _, ctlPath := range controllers {
		ctlPath, j := ctlPath, j.Clone()
		go func() {
			defer j.Close()
			r, err := j.checkCredentialOnController(ctx, ctlPath, newCred)
			ch <- updateCredentialResult{ctlPath, r, err}
		}()
	}
	r, err := mergeUpdateCredentialResults(ctx, ch, len(controllers), true)
	if err != nil {
		return nil, errgo.Mask(err)
	}
	return r, nil
}

type updateCredentialResult struct {
	ctlPath params.EntityPath
	r       *jujuparams.UpdateCredentialResult
	err     error
}

func mergeUpdateCredentialResults(ctx context.Context, ch <-chan updateCredentialResult, n int, errorsAreFatal bool) (*jujuparams.UpdateCredentialResult, error) {
	allResults := new(jujuparams.UpdateCredentialResult)
	for n > 0 {
		select {
		case r := <-ch:
			n--
			if r.err != nil {
				if errorsAreFatal {
					return nil, errgo.Notef(r.err, "controller %s", r.ctlPath)
				}
				zapctx.Warn(ctx,
					"cannot update credential",
					zap.String("controller", r.ctlPath.String()),
					zaputil.Error(r.err),
				)
				continue
			}
			mergeCredentialCheckResult(allResults, r.r)
		case <-ctx.Done():
			return nil, errgo.Notef(ctx.Err(), "timed out checking credentials")
		}
	}
	return allResults, nil
}

func mergeCredentialCheckResult(r1, r2 *jujuparams.UpdateCredentialResult) {
	if r1.CredentialTag == "" {
		r1.CredentialTag = r2.CredentialTag
	}
	if r1.Error == nil {
		r1.Error = r2.Error
	}
	r1.Models = append(r1.Models, r2.Models...)
}

func (j *JEM) checkCredentialOnController(ctx context.Context, ctlPath params.EntityPath, cred *mongodoc.Credential) (*jujuparams.UpdateCredentialResult, error) {
	conn, err := j.OpenAPI(ctx, ctlPath)
	if err != nil {
		return nil, errgo.Mask(err)
	}
	defer conn.Close()
	_, facade := jujuapibase.NewClientFacade(conn, "Cloud")
	if facade.BestAPIVersion() < 3 {
		// If version 3 isn't supported, then the UpdateCredential entry point
		// doesn't check for validity, so there's nothing to do.
		return &jujuparams.UpdateCredentialResult{
			CredentialTag: CloudCredentialTag(cred.Path).String(),
		}, nil
	}
	in := jujuparams.TaggedCredentials{
		Credentials: []jujuparams.TaggedCredential{newJujuCred(cred)},
	}
	var out jujuparams.UpdateCredentialResults
	if err := facade.FacadeCall("CheckCredentialsModels", in, &out); err != nil {
		return nil, errgo.Mask(err)
	}
	if len(out.Results) != 1 {
		return nil, errgo.Newf("invalid result count")
	}
	return &out.Results[0], nil
}

func newJujuCred(cred *mongodoc.Credential) jujuparams.TaggedCredential {
	return jujuparams.TaggedCredential{
		Tag: CloudCredentialTag(cred.Path).String(),
		Credential: jujuparams.CloudCredential{
			AuthType:   string(cred.Type),
			Attributes: cred.Attributes,
		},
	}
}

// ControllerUpdateCredentials updates the given controller by updating
// all outstanding UpdateCredentials.
func (j *JEM) ControllerUpdateCredentials(ctx context.Context, ctlPath params.EntityPath) error {
	ctl, err := j.DB.Controller(ctx, ctlPath)
	if err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrNotFound))
	}
	conn, err := j.OpenAPIFromDoc(ctx, ctl)
	if err != nil {
		return errgo.Notef(err, "cannot connect to controller")
	}
	defer conn.Close()
	for _, credPath := range ctl.UpdateCredentials {
		cred, err := j.DB.Credential(ctx, credPath)
		if err != nil {
			zapctx.Warn(ctx,
				"cannot get credential for controller",
				zap.Stringer("cred", credPath),
				zap.Stringer("controller", ctl.Path),
				zaputil.Error(err),
			)
			continue
		}
		if cred.Revoked {
			if err := j.revokeControllerCredential(ctx, conn, ctl.Path, cred.Path); err != nil {
				zapctx.Warn(ctx,
					"cannot revoke credential",
					zap.Stringer("cred", credPath),
					zap.Stringer("controller", ctl.Path),
					zaputil.Error(err),
				)
			}
		} else {
			if err := j.updateControllerCredential(ctx, conn, ctl.Path, cred, nil); err != nil {
				zapctx.Warn(ctx,
					"cannot update credential",
					zap.Stringer("cred", credPath),
					zap.Stringer("controller", ctl.Path),
					zaputil.Error(err),
				)
			}
		}
	}
	return nil
}

// updateControllerCredential updates the given credential (which must
// not be revoked) on the given controller.
// If rp is non-nil, it will be updated with information
// on the models updated.
func (j *JEM) updateControllerCredential(
	ctx context.Context,
	conn *apiconn.Conn,
	ctlPath params.EntityPath,
	cred *mongodoc.Credential,
	rp **jujuparams.UpdateCredentialResult,
) error {
	if cred.Revoked {
		return errgo.New("updateControllerCredential called with revoked credential (shouldn't happen)")
	}
	r, err := updateCredential(ctx, conn, cred)
	if err != nil {
		return errgo.Notef(err, "cannot update credentials")
	}
	if rp != nil {
		// Our caller wants the UpdateCredentialResult.
		if r == nil {
			// We're talking to an old version of the API that doesn't
			// return full results.
			// TODO fill in r from models known to us.
		}
		*rp = r
	}
	if r != nil && r.Error != nil {
		return errgo.Mask(r.Error)
	}
	if err := j.DB.clearCredentialUpdate(ctx, ctlPath, cred.Path); err != nil {
		return errgo.Notef(err, "cannot update controller %q after successfully updating credntial", ctlPath)
	}
	return nil
}

func (j *JEM) revokeControllerCredential(
	ctx context.Context,
	conn *apiconn.Conn,
	ctlPath params.EntityPath,
	credPath params.CredentialPath,
) error {
	cloudCredentialTag := CloudCredentialTag(credPath)

	_, facade := jujuapibase.NewClientFacade(conn, "Cloud")
	var results jujuparams.ErrorResults
	if facade.BestAPIVersion() < 3 {
		// If we're using an older API version, the Force flag is implied.
		args := jujuparams.Entities{
			Entities: []jujuparams.Entity{{
				Tag: cloudCredentialTag.String(),
			}},
		}
		if err := facade.FacadeCall("RevokeCredentials", args, &results); err != nil {
			return errgo.Mask(err)
		}
	} else {
		// Newer API versions require an explicit Force argument
		// (we're assuming that we've checked earlier, so we always force)
		args := jujuparams.RevokeCredentialArgs{
			Credentials: []jujuparams.RevokeCredentialArg{{
				Tag:   cloudCredentialTag.String(),
				Force: true,
			}},
		}
		if err := facade.FacadeCall("RevokeCredentialsCheckModels", args, &results); err != nil {
			return errgo.Mask(err)
		}
	}
	if err := results.OneError(); err != nil {
		return errgo.Mask(err)
	}
	if err := j.DB.clearCredentialUpdate(ctx, ctlPath, credPath); err != nil {
		return errgo.Notef(err, "cannot update controller %q after successfully updating credntial", ctlPath)
	}
	return nil
}

// updateCredential updates a credential on a controller implied by the
// given API connection.
//
// The first return parameter may include information on models
// that are using the credential.
func updateCredential(ctx context.Context, conn *apiconn.Conn, cred *mongodoc.Credential) (*jujuparams.UpdateCredentialResult, error) {
	_, facade := jujuapibase.NewClientFacade(conn, "Cloud")
	jcreds := []jujuparams.TaggedCredential{newJujuCred(cred)}
	if facade.BestAPIVersion() < 3 {
		// It's an old controller, so the UpdateCredentials entry point doesn't check
		// that the credentials are valid.
		// But we still need to return results with all the models in,
		// so we'll get the models associated with the credential first.
		in := jujuparams.TaggedCredentials{
			Credentials: jcreds,
		}
		var out jujuparams.ErrorResults
		if err := facade.FacadeCall("UpdateCredentials", in, &out); err != nil {
			return nil, errgo.Mask(err)
		}
		return nil, out.OneError()
	}
	in := jujuparams.UpdateCredentialArgs{
		Force:       true,
		Credentials: jcreds,
	}
	var out jujuparams.UpdateCredentialResults
	err := facade.FacadeCall("UpdateCredentialsCheckModels", in, &out)
	switch {
	case err != nil:
		return nil, errgo.Mask(err)
	case len(out.Results) != 1:
		return nil, errgo.New("unexpected result count from UpdateCredentialsCheckModels")
	}
	return &out.Results[0], nil
}

// GrantModel grants the given access for the given user on the given model and updates the JEM database.
func (j *JEM) GrantModel(ctx context.Context, conn *apiconn.Conn, model *mongodoc.Model, user params.User, access string) error {
	if err := j.DB.GrantModel(ctx, model.Path, user, access); err != nil {
		return errgo.Mask(err)
	}
	client := modelmanager.NewClient(conn)
	if err := client.GrantModel(UserTag(user).Id(), access, model.UUID); err != nil {
		return errgo.Mask(err)
	}
	return nil
}

// RevokeModel revokes the given access for the given user on the given model and updates the JEM database.
func (j *JEM) RevokeModel(ctx context.Context, conn *apiconn.Conn, model *mongodoc.Model, user params.User, access string) error {
	if err := j.DB.RevokeModel(ctx, model.Path, user, access); err != nil {
		return errgo.Mask(err)
	}
	client := modelmanager.NewClient(conn)
	if err := client.RevokeModel(UserTag(user).Id(), access, model.UUID); err != nil {
		// TODO (mhilton) What should be done with the changes already made to JEM.
		return errgo.Mask(err)
	}
	return nil
}

// DestroyModel destroys the specified model. The model will have its
// Life set to dying, but won't be removed until it is removed from the
// controller.
func (j *JEM) DestroyModel(ctx context.Context, conn *apiconn.Conn, model *mongodoc.Model, destroyStorage *bool, force *bool, maxWait *time.Duration) error {
	client := modelmanager.NewClient(conn)
	if err := client.DestroyModel(names.NewModelTag(model.UUID), destroyStorage, force, maxWait); err != nil {
		return errgo.Mask(err, jujuparams.IsCodeHasPersistentStorage)
	}
	if err := j.DB.SetModelLife(ctx, model.Controller, model.UUID, "dying"); err != nil {
		// If this update fails then don't worry as the watcher
		// will detect the state change and update as appropriate.
		zapctx.Warn(ctx, "error updating model life", zap.Error(err), zap.String("model", model.UUID))
	}
	j.DB.AppendAudit(ctx, &params.AuditModelDestroyed{
		ID:   model.Id,
		UUID: model.UUID,
	})
	return nil
}

// EarliestControllerVersion returns the earliest agent version
// that any of the available public controllers is known to be running.
// If there are no available controllers or none of their versions are
// known, it returns the zero version.
func (j *JEM) EarliestControllerVersion(ctx context.Context) (version.Number, error) {
	// TOD(rog) cache the result of this for a while, as it changes only rarely
	// and we don't really need to make this extra round trip every
	// time a user connects to the API?
	var v *version.Number
	if err := j.DoControllers(ctx, func(c *mongodoc.Controller) error {
		zapctx.Debug(ctx, "in EarliestControllerVersion", zap.Stringer("controller", c.Path), zap.Stringer("version", c.Version))
		if c.Version == nil {
			return nil
		}
		if v == nil || c.Version.Compare(*v) < 0 {
			v = c.Version
		}
		return nil
	}); err != nil {
		return version.Number{}, errgo.Mask(err)
	}
	if v == nil {
		return version.Number{}, nil
	}
	return *v, nil
}

// DoControllers calls the given function for each controller that
// can be read by the current user that matches the given attributes.
// If the function returns an error, the iteration stops and
// DoControllers returns the error with the same cause.
//
// Note that the same pointer is passed to the do function on
// each iteration. It is the responsibility of the do function to
// copy it if needed.
func (j *JEM) DoControllers(ctx context.Context, do func(c *mongodoc.Controller) error) error {
	// Query all the controllers that match the attributes, building
	// up all the possible values.
	q := j.DB.Controllers().Find(bson.D{{"unavailablesince", notExistsQuery}, {"public", true}})
	// Sort by _id so that we can make easily reproducible tests.
	iter := j.DB.NewCanReadIter(ctx, q.Sort("_id").Iter())
	var ctl mongodoc.Controller
	for iter.Next(&ctl) {
		if err := do(&ctl); err != nil {
			iter.Close()
			return errgo.Mask(err, errgo.Any)
		}
	}
	if err := iter.Err(); err != nil {
		return errgo.Notef(err, "cannot query")
	}
	return nil
}

// selectCredential chooses a credential appropriate for the given user that can
// be used when starting a model in the given cloud.
//
// If there's more than one such credential, it returns a params.ErrAmbiguousChoice error.
//
// If there are no credentials found, a zero credential path is returned.
func (j *JEM) selectCredential(ctx context.Context, path params.CredentialPath, user params.User, cloud params.Cloud) (*mongodoc.Credential, error) {
	query := bson.D{{"path", path}}
	if path.IsZero() {
		query = bson.D{
			{"path.entitypath.user", user},
			{"path.cloud", cloud},
			{"revoked", false},
		}
	}
	var creds []mongodoc.Credential
	iter := j.DB.NewCanReadIter(ctx, j.DB.Credentials().Find(query).Iter())
	var cred mongodoc.Credential
	for iter.Next(&cred) {
		creds = append(creds, cred)
	}
	if err := iter.Err(); err != nil {
		return nil, errgo.Notef(err, "cannot query credentials")
	}
	switch len(creds) {
	case 0:
		var err error
		if !path.IsZero() {
			err = errgo.WithCausef(nil, params.ErrNotFound, "credential %q not found", path)
		}
		return nil, err
	case 1:
		cred := &creds[0]
		if cred.Revoked {
			// The credential (which must have been specifically selected by
			// path, because if the path wasn't set, we will never select
			// a revoked credential) has been revoked - we can't use it.
			return nil, errgo.Newf("credential %v has been revoked", creds[0].Path)
		}
		return cred, nil
	default:
		return nil, errgo.WithCausef(nil, params.ErrAmbiguousChoice, "more than one possible credential to use")
	}
}

// selectRandomController chooses a random controller that you have access to.
func (j *JEM) selectRandomController(ctx context.Context) (params.EntityPath, error) {
	// Choose a random controller.
	// TODO select a controller more intelligently, for example
	// by choosing the most lightly loaded controller
	var controllers []mongodoc.Controller
	if err := j.DoControllers(ctx, func(c *mongodoc.Controller) error {
		controllers = append(controllers, *c)
		return nil
	}); err != nil {
		return params.EntityPath{}, errgo.Mask(err)
	}
	if len(controllers) == 0 {
		return params.EntityPath{}, errgo.Newf("cannot find a suitable controller")
	}
	n := randIntn(len(controllers))
	return controllers[n].Path, nil
}

// UpdateMachineInfo updates the information associated with a machine.
func (j *JEM) UpdateMachineInfo(ctx context.Context, ctlPath params.EntityPath, info *multiwatcher.MachineInfo) error {
	cloud, region, err := j.modelRegion(ctx, ctlPath, info.ModelUUID)
	if errgo.Cause(err) == params.ErrNotFound {
		// If the model isn't found then it is not controlled by
		// JIMM and we aren't interested in it.
		return nil
	}
	if err != nil {
		return errgo.Notef(err, "cannot find region for model %s:%s", ctlPath, info.ModelUUID)
	}
	return errgo.Mask(j.DB.UpdateMachineInfo(ctx, &mongodoc.Machine{
		Controller: ctlPath.String(),
		Cloud:      cloud,
		Region:     region,
		Info:       info,
	}))
}

// UpdateApplicationInfo updates the information associated with an application.
func (j *JEM) UpdateApplicationInfo(ctx context.Context, ctlPath params.EntityPath, info *multiwatcher.ApplicationInfo) error {
	cloud, region, err := j.modelRegion(ctx, ctlPath, info.ModelUUID)
	if errgo.Cause(err) == params.ErrNotFound {
		// If the model isn't found then it is not controlled by
		// JIMM and we aren't interested in it.
		return nil
	}
	if err != nil {
		return errgo.Notef(err, "cannot find region for model %s:%s", ctlPath, info.ModelUUID)
	}
	app := &mongodoc.Application{
		Controller: ctlPath.String(),
		Cloud:      cloud,
		Region:     region,
	}
	if info != nil {
		app.Info = &mongodoc.ApplicationInfo{
			ModelUUID:       info.ModelUUID,
			Name:            info.Name,
			Exposed:         info.Exposed,
			CharmURL:        info.CharmURL,
			OwnerTag:        info.OwnerTag,
			Life:            info.Life,
			Subordinate:     info.Subordinate,
			Status:          info.Status,
			WorkloadVersion: info.WorkloadVersion,
		}
	}
	return errgo.Mask(j.DB.UpdateApplicationInfo(ctx, app))
}

// modelRegion determines the cloud and region in which a model is contained.
func (j *JEM) modelRegion(ctx context.Context, ctlPath params.EntityPath, uuid string) (params.Cloud, string, error) {
	type cloudRegion struct {
		cloud  params.Cloud
		region string
	}
	key := fmt.Sprintf("%s %s", ctlPath, uuid)
	r, err := j.pool.regionCache.Get(key, func() (interface{}, error) {
		m, err := j.DB.modelFromControllerAndUUID(ctx, ctlPath, uuid)
		if err != nil {
			return nil, errgo.Mask(err, errgo.Is(params.ErrNotFound))
		}
		return cloudRegion{
			cloud:  m.Cloud,
			region: m.CloudRegion,
		}, nil
	})
	if err != nil {
		return "", "", errgo.Mask(err, errgo.Is(params.ErrNotFound))
	}
	cr := r.(cloudRegion)
	return cr.cloud, cr.region, nil
}

// A CreateCloudParams is used to pass additional cloud information to
// CreateCloud.
type CreateCloudParams struct {
	HostCloudRegion string
	Config          map[string]interface{}
	RegionConfig    map[string]map[string]interface{}
}

// CreateCloud creates a new cloud in the database and adds it to a
// controller. If the cloud name already exists then an error with a
// cause of params.ErrAlreadyExists will be returned.
func (j *JEM) CreateCloud(ctx context.Context, cloud mongodoc.CloudRegion, regions []mongodoc.CloudRegion, ccp CreateCloudParams) error {
	if _, ok := j.pool.config.PublicCloudMetadata[string(cloud.Cloud)]; ok {
		// The cloud uses the name of a public cloud, we assume
		// these already exist (even if they don't yet).
		return errgo.WithCausef(nil, params.ErrAlreadyExists, "cloud %q already exists", cloud.Cloud)
	}

	// Attempt to insert the document for the cloud and fail early if
	// such a cloud exists.
	if err := j.DB.InsertCloudRegion(ctx, &cloud); err != nil {
		if errgo.Cause(err) == params.ErrAlreadyExists {
			return errgo.WithCausef(nil, params.ErrAlreadyExists, "cloud %q already exists", cloud.Cloud)
		}
		return errgo.Mask(err)
	}
	var regionConfig map[string]jujucloud.Attrs
	for r, attr := range ccp.RegionConfig {
		if regionConfig == nil {
			regionConfig = make(map[string]jujucloud.Attrs)
		}
		regionConfig[r] = attr
	}
	jcloud := jujucloud.Cloud{
		Name:             string(cloud.Cloud),
		Type:             cloud.ProviderType,
		Endpoint:         cloud.Endpoint,
		IdentityEndpoint: cloud.IdentityEndpoint,
		StorageEndpoint:  cloud.StorageEndpoint,
		CACertificates:   cloud.CACertificates,
		HostCloudRegion:  ccp.HostCloudRegion,
		Config:           ccp.Config,
		RegionConfig:     regionConfig,
	}
	for _, authType := range cloud.AuthTypes {
		jcloud.AuthTypes = append(jcloud.AuthTypes, jujucloud.AuthType(authType))
	}
	for _, reg := range regions {
		jcloud.Regions = append(jcloud.Regions, jujucloud.Region{
			Name:             reg.Region,
			Endpoint:         reg.Endpoint,
			IdentityEndpoint: reg.IdentityEndpoint,
			StorageEndpoint:  reg.StorageEndpoint,
		})
	}
	ctlPath, err := j.createCloud(ctx, jcloud)
	if err != nil {
		if err := j.DB.RemoveCloudRegion(ctx, cloud.Cloud, ""); err != nil {
			zapctx.Warn(ctx, "cannot remove cloud that failed to deploy", zaputil.Error(err))
		}
		return errgo.Mask(err, errgo.Is(params.ErrCloudRegionRequired), errgo.Is(params.ErrNotFound), errgo.Is(params.ErrUnauthorized))
	}
	cloud.PrimaryControllers = []params.EntityPath{ctlPath}
	for i := range regions {
		regions[i].PrimaryControllers = []params.EntityPath{ctlPath}
	}
	if err := j.DB.UpdateCloudRegions(ctx, append(regions, cloud)); err != nil {
		return errgo.Mask(err)
	}
	j.DB.AppendAudit(ctx, &params.AuditCloudCreated{
		ID:     cloud.Id,
		Cloud:  string(cloud.Cloud),
		Region: cloud.Region,
	})
	return nil
}

func (j *JEM) createCloud(ctx context.Context, cloud jujucloud.Cloud) (params.EntityPath, error) {
	parts := strings.SplitN(cloud.HostCloudRegion, "/", 2)
	if len(parts) != 2 || parts[0] == "" {
		return params.EntityPath{}, errgo.WithCausef(nil, params.ErrCloudRegionRequired, "")
	}

	ctlPaths, err := j.possibleControllers(ctx, params.EntityPath{}, params.Cloud(parts[0]), parts[1])
	if err != nil {
		return params.EntityPath{}, errgo.Mask(err, errgo.Is(params.ErrNotFound), errgo.Is(params.ErrUnauthorized))
	}
	errors := make([]error, len(ctlPaths))
	for i, ctlPath := range ctlPaths {
		conn, err := j.OpenAPI(ctx, ctlPath)
		if err != nil {
			errors[i] = err
			zapctx.Error(ctx, "cannot connect to controller", zap.Stringer("controller", ctlPath), zaputil.Error(err))
			continue
		}
		defer conn.Close()
		err = cloudapi.NewClient(conn).AddCloud(cloud)
		if err == nil {
			return ctlPath, nil
		}
		zapctx.Error(ctx, "cannot create cloud", zap.Stringer("controller", ctlPath), zaputil.Error(err))
		errors[i] = err
		continue
	}
	if len(errors) > 0 {
		// TODO(mhilton) perhaps filter errors to find the "best" one.
		return params.EntityPath{}, errgo.Mask(errors[0])
	}
	return params.EntityPath{}, errgo.New("cannot create cloud")
}

// RemoveCloud removes the given cloud, so long as no models are using it.
func (j *JEM) RemoveCloud(ctx context.Context, cloud params.Cloud) (err error) {
	cr, err := j.DB.CloudRegion(ctx, cloud, "")
	if err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrNotFound), errgo.Is(params.ErrUnauthorized))
	}
	if err := auth.CheckACL(ctx, cr.ACL.Admin); err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}
	// This check is technically redundant as we can't know whether
	// the cloud is in use by any models at the moment we remove it from a controller
	// (remember that only one of the primary controllers might be using it).
	// However we like the error message and it's usually going to be OK,
	// so we'll do the advance check anyway.
	if n, err := j.DB.Models().Find(bson.D{{"cloud", cloud}}).Count(); n > 0 || err != nil {
		if err != nil {
			return errgo.Mask(err)
		}
		return errgo.Newf("cloud is used by %d model%s", n, plural(n))
	}
	// TODO delete the cloud from the controllers in parallel
	// (although currently there is only ever one anyway).
	for _, ctl := range cr.PrimaryControllers {
		conn, err := j.OpenAPI(ctx, ctl)
		if err != nil {
			return errgo.Mask(err)
		}
		defer conn.Close()
		if err := cloudapi.NewClient(conn).RemoveCloud(string(cloud)); err != nil {
			return errgo.Notef(err, "cannot remove cloud from controller %s", ctl)
		}
	}
	if err := j.DB.RemoveCloud(ctx, cloud); err != nil {
		return errgo.Mask(err)
	}
	j.DB.AppendAudit(ctx, &params.AuditCloudRemoved{
		ID:     cr.Id,
		Cloud:  string(cr.Cloud),
		Region: cr.Region,
	})
	return nil
}

// GrantCloud grants access to the given cloud at the given access level to the given user.
func (j *JEM) GrantCloud(ctx context.Context, cloud params.Cloud, user params.User, access string) error {
	cr, err := j.DB.CloudRegion(ctx, cloud, "")
	if err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrNotFound))
	}
	if err := auth.CheckACL(ctx, cr.ACL.Admin); err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}
	if err := j.DB.GrantCloud(ctx, cloud, user, access); err != nil {
		return errgo.Mask(err)
	}
	// TODO grant the cloud access on the controllers in parallel
	// (although currently there is only ever one anyway).
	for _, ctl := range cr.PrimaryControllers {
		conn, err := j.OpenAPI(ctx, ctl)
		if err != nil {
			return errgo.Mask(err)
		}
		defer conn.Close()
		if err := cloudapi.NewClient(conn).GrantCloud(UserTag(user).String(), access, string(cloud)); err != nil {
			// TODO(mhilton) If this happens then the
			// controller will be in an inconsistent state
			// with JIMM. Try and resolve this.
			return errgo.Mask(err)
		}
	}
	return nil
}

// RevokeCloud revokes access to the given cloud at the given access level from the given user.
func (j *JEM) RevokeCloud(ctx context.Context, cloud params.Cloud, user params.User, access string) error {
	cr, err := j.DB.CloudRegion(ctx, cloud, "")
	if err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrNotFound))
	}
	if err := auth.CheckACL(ctx, cr.ACL.Admin); err != nil {
		return errgo.Mask(err, errgo.Is(params.ErrUnauthorized))
	}
	// TODO revoke the cloud access on the controllers in parallel
	// (although currently there is only ever one anyway).
	for _, ctl := range cr.PrimaryControllers {
		conn, err := j.OpenAPI(ctx, ctl)
		if err != nil {
			return errgo.Mask(err)
		}
		defer conn.Close()
		if err := cloudapi.NewClient(conn).RevokeCloud(UserTag(user).String(), access, string(cloud)); err != nil {
			return errgo.Mask(err)
		}
	}
	if err := j.DB.RevokeCloud(ctx, cloud, user, access); err != nil {
		return errgo.Mask(err)
	}
	return nil
}

// UpdateModelCredential updates the credential used with a model on both
// the controller and the local database.
func (j *JEM) UpdateModelCredential(ctx context.Context, conn *apiconn.Conn, model *mongodoc.Model, cred *mongodoc.Credential) error {
	if err := j.updateControllerCredential(ctx, conn, model.Controller, cred, nil); err != nil {
		return errgo.Notef(err, "cannot add credential")
	}
	if err := j.DB.credentialAddController(ctx, cred.Path, model.Controller); err != nil {
		return errgo.Notef(err, "cannot add credential")
	}

	client := modelmanager.NewClient(conn)
	if err := client.ChangeModelCredential(names.NewModelTag(model.UUID), CloudCredentialTag(cred.Path)); err != nil {
		return errgo.Mask(err)
	}

	if err := j.DB.SetModelCredential(ctx, model.Path, cred.Path); err != nil {
		return errgo.Mask(err)
	}
	return nil
}

func plural(n int) string {
	if n == 1 {
		return ""
	}
	return "s"
}

// UserTag creates a juju user tag from a params.User
func UserTag(u params.User) names.UserTag {
	tag := names.NewUserTag(string(u))
	if tag.IsLocal() {
		tag = tag.WithDomain("external")
	}
	return tag
}

// CloudTag creates a juju cloud tag from a params.Cloud
func CloudTag(c params.Cloud) names.CloudTag {
	return names.NewCloudTag(string(c))
}

// CloudCredentialTag creates a juju cloud credential tag from the given
// CredentialPath.
func CloudCredentialTag(p params.CredentialPath) names.CloudCredentialTag {
	if p.IsZero() {
		return names.CloudCredentialTag{}
	}
	user := UserTag(p.User)
	return names.NewCloudCredentialTag(fmt.Sprintf("%s/%s/%s", p.Cloud, user.Id(), p.Name))
}
