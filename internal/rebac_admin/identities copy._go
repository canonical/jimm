// Copyright 2024 Canonical Ltd.

// GET METHOD for IDENTITY
// GET/PATCH groups
// GET/PATCH roles -> not implemented
// GET/PATCH entitlements

package rebac_admin

import (
	"context"
	"fmt"

	apiparams "github.com/canonical/jimm/api/params"
	"github.com/canonical/jimm/internal/jimm"
	"github.com/canonical/jimm/internal/openfga"
	"github.com/canonical/jimm/internal/openfga/names"
	"github.com/canonical/jimm/internal/rebac_admin/utils"
	"github.com/juju/zaputil/zapctx"
	"go.uber.org/zap"

	v1 "github.com/canonical/rebac-admin-ui-handlers/v1"
	"github.com/canonical/rebac-admin-ui-handlers/v1/resources"
)

// identitiesService implements the `identitiesService` interface.
type identitiesService struct {
	jimm *jimm.JIMM
}

func newidentitiesService(jimm *jimm.JIMM) *identitiesService {
	return &identitiesService{
		jimm: jimm,
	}
}

// ListIdentities returns a page of Identity objects of at least `size` elements if available
func (s *identitiesService) ListIdentities(ctx context.Context, params *resources.GetIdentitiesParams) (*resources.PaginatedResponse[resources.Identity], error) {
	// TODO: extract identity from auth middleware
	// raw, _ := v1.GetIdentityFromContext(ctx)
	// user, _ := raw.(*openfga.User)
	page, pagination := utils.CreatePagination(params)
	zapctx.Error(ctx, fmt.Sprintf("pagination: %#v", pagination))
	nextPage := page + 1

	users, err := s.jimm.ListUsers(ctx, &openfga.User{}, pagination)
	if err != nil {
		return nil, err
	}
	rIdentities := make([]resources.Identity, len(users))
	for i, u := range users {
		rIdentities[i] = utils.ParseFromUserToIdentity(u)
	}

	return &resources.PaginatedResponse[resources.Identity]{
		Data: rIdentities,
		Meta: resources.ResponseMeta{
			Page: &page,
			Size: pagination.Limit(),
		},
		Next: resources.Next{
			Page: &nextPage,
		},
	}, nil
}

// CreateIdentity creates a single Identity.
func (s *identitiesService) CreateIdentity(ctx context.Context, identity *resources.Identity) (*resources.Identity, error) {
	return nil, v1.NewNotImplementedError("create identity not implemented")
}

// GetIdentity returns a single Identity.
func (s *identitiesService) GetIdentity(ctx context.Context, identityId string) (*resources.Identity, error) {
	user, err := s.jimm.FetchUser(ctx, identityId)
	if err != nil {
		return nil, v1.NewNotFoundError(fmt.Sprintf("User with id %s not found", identityId))
	}
	identity := utils.ParseFromUserToIdentity(*user)
	return &identity, nil
}

// UpdateIdentity updates an Identity.
func (s *identitiesService) UpdateIdentity(ctx context.Context, identity *resources.Identity) (*resources.Identity, error) {
	return nil, v1.NewNotImplementedError("update identity not implemented")
}

// // DeleteIdentity deletes an Identity
// // returns (true, nil) in case an identity was successfully delete
// // return (false, error) in case something went wrong
// // implementors may want to return (false, nil) for idempotency cases
func (s *identitiesService) DeleteIdentity(ctx context.Context, identityId string) (bool, error) {
	return false, v1.NewNotImplementedError("delete identity not implemented")
}

// GetIdentityGroups returns a page of Groups for identity `identityId`.
func (s *identitiesService) GetIdentityGroups(ctx context.Context, identityId string, params *resources.GetIdentitiesItemGroupsParams) (*resources.PaginatedResponse[resources.Group], error) {
	user, err := s.jimm.GetUser(ctx, identityId)
	if err != nil {
		return nil, v1.NewNotFoundError(fmt.Sprintf("User with id %s not found", identityId))
	}

	if params.NextPageToken != nil || params.NextToken != nil {
		return nil, v1.NewNotFoundError("not supporting pagination via token")
	}

	groups, err := user.ListGroups(ctx)

	// pagination := pagination.NewOffsetFilter(*params.Size, (*params.Page)*(*params.Size))
	nextPage := (*params.Page + 1)
	// groups, err := s.jimm.ListGroups(ctx, user, pagination)
	// if err != nil {
	// 	return nil, err
	// }
	rGroups := make([]resources.Group, len(groups))
	for i, g := range groups {
		rGroups[i] = resources.Group{
			Name: g,
		}
	}

	return &resources.PaginatedResponse[resources.Group]{
		Data: rGroups,
		Meta: resources.ResponseMeta{
			Page: params.Page,
			Size: *params.Size,
		},
		Next: resources.Next{
			Page: &nextPage,
		},
	}, nil
}

// // PatchIdentityGroups performs addition or removal of a Group to/from an Identity.
func (s *identitiesService) PatchIdentityGroups(ctx context.Context, identityId string, groupPatches []resources.IdentityGroupsPatchItem) (bool, error) {
	additions := make([]apiparams.RelationshipTuple, 0)
	deletions := make([]apiparams.RelationshipTuple, 0)
	for _, p := range groupPatches {
		if p.Op == "add" {
			additions = append(additions, apiparams.RelationshipTuple{
				Object:       identityId,
				Relation:     names.MemberRelation.String(),
				TargetObject: p.Group,
			})
		} else if p.Op == "remove" {
			deletions = append(deletions, apiparams.RelationshipTuple{
				Object:       identityId,
				Relation:     names.MemberRelation.String(),
				TargetObject: p.Group,
			})
		}
	}

	err := s.jimm.AddRelation(ctx, nil, additions)
	if err != nil {
		zapctx.Error(context.Background(), "cannot add relations", zap.Error(err))
		return false, v1.NewUnknownError(err.Error())
	}
	err = s.jimm.RemoveRelation(ctx, nil, additions)
	if err != nil {
		zapctx.Error(context.Background(), "cannot remove relations", zap.Error(err))
		return false, v1.NewUnknownError(err.Error())
	}

	return true, nil
}

// // GetIdentityRoles returns a page of Roles for identity `identityId`.
func (s *identitiesService) GetIdentityRoles(ctx context.Context, identityId string, params *resources.GetIdentitiesItemRolesParams) (*resources.PaginatedResponse[resources.Role], error) {
	return nil, v1.NewNotImplementedError("get identity roles not implemented")
}

// // PatchIdentityRoles performs addition or removal of a Role to/from an Identity.
func (s *identitiesService) PatchIdentityRoles(ctx context.Context, identityId string, rolePatches []resources.IdentityRolesPatchItem) (bool, error) {
	return false, v1.NewNotImplementedError("get identity roles not implemented")

}

// // GetIdentityEntitlements returns a page of Entitlements for identity `identityId`.
func (s *identitiesService) GetIdentityEntitlements(ctx context.Context, identityId string, params *resources.GetIdentitiesItemEntitlementsParams) (*resources.PaginatedResponse[resources.EntityEntitlement], error) {
	user, err := s.jimm.GetUser(ctx, identityId)
	if err != nil {
		return nil, v1.NewNotFoundError(fmt.Sprintf("User with id %s not found", identityId))
	}
	s.jimm.ListRelationshipTuples(ctx, user)

	return nil, v1.NewAuthorizationError("cannot create entity.")
}

// // PatchIdentityEntitlements performs addition or removal of an Entitlement to/from an Identity.
func (s *identitiesService) PatchIdentityEntitlements(ctx context.Context, identityId string, entitlementPatches []resources.IdentityEntitlementsPatchItem) (bool, error) {
	user, err := s.jimm.GetUser(ctx, identityId)
	if err != nil {
		return false, v1.NewNotFoundError(fmt.Sprintf("User with id %s not found", identityId))
	}
	additions := make([]apiparams.RelationshipTuple, 0)
	removals := make([]apiparams.RelationshipTuple, 0)

	for _, p := range entitlementPatches {
		if p.Op == "add" {
			additions = append(additions, apiparams.RelationshipTuple{
				Object:       p.Entitlement.EntityId,
				Relation:     p.Entitlement.Entitlement,
				TargetObject: p.Entitlement.EntityType,
			})
		} else if p.Op == "remove" {
			removals = append(removals, apiparams.RelationshipTuple{
				Object:       p.Entitlement.EntityId,
				Relation:     p.Entitlement.Entitlement,
				TargetObject: p.Entitlement.EntityType,
			})
		}
	}
	err = s.jimm.AddRelation(ctx, user, additions)
	if err != nil {
		zapctx.Error(context.Background(), "cannot add relations", zap.Error(err))
		return false, v1.NewUnknownError(err.Error())
	}
	err = s.jimm.RemoveRelation(ctx, user, removals)
	if err != nil {
		zapctx.Error(context.Background(), "cannot remove relations", zap.Error(err))
	}

	return true, nil
}
